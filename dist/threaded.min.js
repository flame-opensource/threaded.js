class Thread{constructor(e,r,t){if(void 0===Thread.count&&(Thread.count=0),Thread.count++,this.__generatorFunc__=ThreadExecutor.__generatorFunc__(e),this.id=void 0===t?"anonymous thread n-"+Thread.count:t+" (thread n-"+Thread.count+")",void 0===ThreadExecutor.queue&&(ThreadExecutor.queue=[]),this.__sleepingpriority__=!1,this.__resumingpriority__=!1,this.__stepscount__=0,void 0!==r){if("number"!=typeof r)throw new ThreadError(this,"thread priority level must be a valid number");if(!Number.isInteger(r))throw new ThreadError(this,"thread priority level must be an integer number");if(r<0)throw new ThreadError(this,"thread priority level must be a positive number");this.prioritylevel=r}else this.prioritylevel=1|(r??1);this.started=!1,this.running=!1,this.stopped=!1,this.paused=!1}setId(e){return this.id=null==e?"anonymous thread n-"+Thread.count:e+" (thread n-"+Thread.count+")",this}toString(){return this.id}stepsCount(){return this.__stepscount__}setPriorityLevel(e){if("number"!=typeof e)throw new ThreadError(this,"thread priority level must be a valid number");if(!Number.isInteger(e))throw new ThreadError(this,"thread priority level must be an integer number");if(e<0)throw new ThreadError(this,"thread priority level must be a positive number");return this.prioritylevel=e,ThreadExecutor.notifyForPriority(),this}start(){return this.__generator__=void 0,this.__stepscount__=0,this.__sleepingpriority__=!1,this.__resumingpriority__=!1,this.started=!0,this.paused=!1,this.stopped=!1,this.running=!0,ThreadExecutor.queue.push(this),ThreadExecutor.isHandling()||ThreadExecutor.handleThreadQueue(),this}startAfter(e){return this.paused||this.pause(),setTimeout((()=>this.start()),e),this}interrupt(){return this.stop()}interruptAfter(e){return this.paused||this.pause(),setTimeout((()=>this.interrupt()),e),this}stop(){if(!this.started)return console.error("Thread not started yet"),this;if(this.stopped)return console.error("Thread already stopped"),this;this.stopped=!0,this.running=!1;const e=ThreadExecutor.queue.indexOf(this);if(-1===e)throw Error('Cannot stop thread "'+sleptThread.id+", the thread is not in the execution queue");return ThreadExecutor.queue.splice(e,1),this}stopAfter(e){return setTimeout((()=>this.stop()),e),this}pause(){if(!this.paused)return this.paused=!0,this;console.error("Thread already paused")}pauseAfter(e){return setTimeout((()=>this.pause()),e),this}resume(){if(!this.paused)return void console.error("Thread is not paused");const e=ThreadExecutor.queue.indexOf(this);if(-1===e)throw Error('Cannot resume thread "'+sleptThread.id+", the thread is not in the execution queue");return this.paused=!1,this.__resumingpriority__=!0,ThreadExecutor.notifyForResuming(this,e),this}resumeAfter(e){return setTimeout((()=>this.resume()),e),this}sleep(e){return Thread.__sleepImpl__(this,e),this}sleepAfter(e){return setTimeout((()=>this.sleep()),e),this}catch(e){return this.__exceptionFunc__=e,this}static sleep(e){const r=ThreadExecutor.currentThread;if(null==r)throw Error("Thread.sleep called outside a thread environment");Thread.__sleepImpl__(r,e)}static __sleepImpl__(e,r){if(!e.started)throw Error('Cannot sleep thread "'+e.id+", the thread is not started yet");if(e.stopped)throw Error('Cannot sleep thread "'+e.id+", the thread is stopped");if(!e.running)throw Error('Cannot sleep thread "'+e.id+", the thread is not running");if(e.paused)throw Error('Cannot sleep thread "'+e.id+", the thread is paused");const t=ThreadExecutor.queue.indexOf(e);if(-1===t)throw Error('Cannot sleep thread "'+e.id+", the thread is not in the execution queue");e.sleeping=!0,e.__sleepingpriority__=!0,setTimeout((()=>ThreadExecutor.notifyForSleeping(e,t)),r)}}Thread.LOW_PRIORITY_LEVEL=1,Thread.MID_PRIORITY_LEVEL=2,Thread.HIGH_PRIORITY_LEVEL=3;class ThreadExecutor{static handleThreadQueue(){void 0!==ThreadExecutor.queue&&0!==ThreadExecutor.queue.length&&(ThreadExecutor.__isLooping__=!0,ThreadExecutor.__isHandling__=!1,ThreadExecutor.queueIndex=0,ThreadExecutor.handlerLoop(!1))}static handlerLoop(e){if(void 0!==ThreadExecutor.__timeSpentOutsideThreads__){let e=new Date;ThreadExecutor.__timeSpentOutsideThreads__=e-ThreadExecutor.__timeSpentOutsideThreads__+5}else ThreadExecutor.__timeSpentOutsideThreads__=20;if(!e&&ThreadExecutor.__isHandling__)return;const r=ThreadExecutor.queue[ThreadExecutor.queueIndex];if(null!=r)if(r.sleeping||!r.started||r.stopped||!r.running||r.paused)ThreadExecutor.queueIndex++,ThreadExecutor.queueIndex=ThreadExecutor.queueIndex%ThreadExecutor.queue.length;else{ThreadExecutor.__isHandling__=!0,ThreadExecutor.currentThread=r,r.__sleepingpriority__=!1,r.__resumingpriority__=!1,void 0===r.__generator__&&(r.__generator__=r.__generatorFunc__());const e=r.__generator__.next();r.__stepscount__="number"==typeof e.value?e.value:r.__stepscount__,e instanceof Error||!0!==e.done?(ThreadExecutor.queueIndex++,ThreadExecutor.queueIndex=ThreadExecutor.queueIndex%ThreadExecutor.queue.length):(r.__stepscount__++,ThreadExecutor.queue.splice(ThreadExecutor.queueIndex,1),r.stopped=!0,r.running=!1,r.__sleepingpriority__=!1,r.__resumingpriority__=!1,ThreadExecutor.queueIndex>=ThreadExecutor.queue.length&&(ThreadExecutor.queueIndex=0)),ThreadExecutor.__isHandling__=!1}0!==ThreadExecutor.queue.length?(setTimeout((()=>ThreadExecutor.handlerLoop(!1)),void 0===ThreadExecutor.__loopingbeattime__||-1===ThreadExecutor.__loopingbeattime__?ThreadExecutor.__timeSpentOutsideThreads__:ThreadExecutor.__loopingbeattime__),ThreadExecutor.__timeSpentOutsideThreads__=new Date):ThreadExecutor.__isLooping__=!1}static isHandling(){return void 0!==ThreadExecutor.__isHandling__&&ThreadExecutor.__isHandling__}static isLooping(){return void 0!==ThreadExecutor.__isLooping__&&ThreadExecutor.__isLooping__}static setBeatTime(e){ThreadExecutor.__loopingbeattime__=e}static notifyForSleeping(e,r){for(let t=0;t<ThreadExecutor.queue.length;t++){if(!ThreadExecutor.queue[t].__sleepingpriority__){ThreadExecutor.queue.splice(r,1),ThreadExecutor.queue.splice(t,0,e);break}}e.sleeping=!1,ThreadExecutor.isLooping()?ThreadExecutor.handlerLoop(!0):ThreadExecutor.handleThreadQueue()}static notifyForResuming(e,r){for(let t=0;t<ThreadExecutor.queue.length;t++){const o=ThreadExecutor.queue[t];if(!o.__sleepingpriority__&&!o.__resumingpriority__){ThreadExecutor.queue.splice(r,1),ThreadExecutor.queue.splice(t,0,e);break}}ThreadExecutor.isLooping()?ThreadExecutor.handlerLoop(!0):ThreadExecutor.handleThreadQueue()}static notifyForPriority(){let e=ThreadExecutor.queue.length;for(let r=0;r<ThreadExecutor.queue.length;r++){const t=ThreadExecutor.queue[r];if(!t.__sleepingpriority__&&!t.__resumingpriority__){e=r;break}}ThreadExecutor.queue.length-e!=0&&(ThreadExecutor.queue=ThreadExecutor.queue.slice(0,e).concat(ThreadExecutor.queue.slice(e,ThreadExecutor.queue.length).sort(((e,r)=>(1|(e.prioritylevel??1))-(1|(r.prioritylevel??1))))),ThreadExecutor.isLooping()?ThreadExecutor.handlerLoop(!0):ThreadExecutor.handleThreadQueue())}static catch(e){ThreadExecutor.__globalExceptionFunc__=e}static __threadExceptionOccurred__(e){if(e instanceof TypeError&&"Generator is already running"===e.message)return;e=new ThreadError(ThreadExecutor.currentThread,e);let r=!1;void 0!==ThreadExecutor.__globalExceptionFunc__&&null!==ThreadExecutor.__globalExceptionFunc__?ThreadExecutor.__globalExceptionFunc__(e,ThreadExecutor.currentThread):r=!0,void 0!==ThreadExecutor.currentThread&&null!==ThreadExecutor.currentThread&&(void 0!==ThreadExecutor.currentThread.__threadgroup__&&null!==ThreadExecutor.currentThread.__threadgroup__&&void 0!==ThreadExecutor.currentThread.__threadgroup__.__exceptionFunc__&&null!==ThreadExecutor.currentThread.__threadgroup__.__exceptionFunc__&&(r=!1,ThreadExecutor.currentThread.__threadgroup__.__exceptionFunc__(e,ThreadExecutor.currentThread)),void 0!==ThreadExecutor.currentThread.__exceptionFunc__&&null!==ThreadExecutor.currentThread.__exceptionFunc__&&(r=!1,ThreadExecutor.currentThread.__exceptionFunc__(e)),r&&console.error(e))}static __generatorFunc__(func){let functionSource=`(${func.toString()})`;if(null===functionSource)throw Error("Failed to retrieve the function source code");if(functionSource.includes("[native code]"))throw Error("Can't execute native function \""+functionSource+'", the thread function has to be a normal function, try to wrap the function into a normal function instead...');const ast=acorn.parse(functionSource,{ecmaVersion:2020});acorn.walk.full(ast,(e=>{if("BlockStatement"===e.type){const r=[];for(let t=0;t<e.body.length;t++){const o=e.body[t];r.push(o),t<e.body.length-1&&"ReturnStatement"!==o.type&&"ContinueStatement"!==o.type&&"BreakStatement"!==o.type&&"ThrowStatement"!==o.type&&r.push({type:"ExpressionStatement",expression:{type:"YieldExpression",argument:{type:"UpdateExpression",operator:"++",argument:{type:"Identifier",name:"__thefunctionstepscount__"},prefix:!1}}})}return e.body=r,e}})),acorn.walk.simple(ast,{FunctionDeclaration(e){e.generator=!0,ThreadExecutor.__wrapFunctionBodyInTryCatch__(e)},FunctionExpression(e){e.generator=!0,ThreadExecutor.__wrapFunctionBodyInTryCatch__(e)},ArrowFunctionExpression(e){"BlockStatement"!==e.body.type&&ThreadExecutor.__wrapArrowFunctionInBlockStatement__(e),e.type="FunctionExpression",e.generator=!0,e.expression=!1,ThreadExecutor.__wrapFunctionBodyInTryCatch__(e)}});let newCode=escodegen.generate(ast),generatorFunc=eval(newCode);return generatorFunc}static __wrapArrowFunctionInBlockStatement__(e){e.body;e.expression&&(e.body={type:"BlockStatement",body:[{type:"ReturnStatement",argument:e.body}]},e.expression=!1)}static __wrapFunctionBodyInTryCatch__(e){const r=e.body.body;e.body.body=[{type:"TryStatement",block:{type:"BlockStatement",body:[{type:"VariableDeclaration",declarations:[{type:"VariableDeclarator",id:{type:"Identifier",name:"__thefunctionstepscount__"},init:{type:"Literal",value:0}}],kind:"let"},...r]},handler:{type:"CatchClause",param:{type:"Identifier",name:"ex"},body:{type:"BlockStatement",body:[{type:"ExpressionStatement",expression:{type:"CallExpression",callee:{type:"MemberExpression",object:{type:"Identifier",name:"ThreadExecutor"},property:{type:"Identifier",name:"__threadExceptionOccurred__"}},arguments:[{type:"Identifier",name:"ex"}]}},{type:"ReturnStatement",argument:{type:"Identifier",name:"ex"}}]}},finalizer:null}]}}ThreadExecutor.ADAPTIVE=-1;class ThreadGroup{constructor(...e){if(void 0===ThreadGroup.count&&(ThreadGroup.count=0),ThreadGroup.count++,this.id="anonymous threadgroup n-"+ThreadGroup.count,null==e)throw new ThreadError(this,"threadgroup given threads array is undefined or null");this.threads=e;for(const e of this.threads)null!=e&&(e.__threadgroup__=this)}setId(e){return this.id=null==e?"anonymous threadgroup n-"+ThreadGroup.count:e+" (threadgroup n-"+ThreadGroup.count+")",this}add(e){if(null==e)throw new ThreadError(this,"Given thread in threadgroup add function is undefined or null");return this.threads.push(e),e.__threadgroup__=this,this}remove(e){if(null==e)return;const r=this.threads.indexOf(e);if(-1===r)throw new ThreadError('Cannot remove thread "'+e.id+" from threadgroup, the thread is not added to that threadgroup");return this.threads.splice(r,1),e.__threadgroup__=void 0,this}stepsCount(){if(0==this.threads.length)throw new ThreadError(this,"threadgroup has no threads");let e=0;for(const r of this.threads)null!=r&&(e+=r.stepsCount());return e}start(){if(0==this.threads.length)throw new ThreadError(this,"threadgroup has no threads");for(const e of this.threads)null!=e&&e.start();return this}startAfter(e){if(0==this.threads.length)throw new ThreadError(this,"threadgroup has no threads");return this.pause(),setTimeout((()=>this.start()),e),this}interrupt(){if(0==this.threads.length)throw new ThreadError(this,"threadgroup has no threads");return this.stop()}interruptAfter(e){if(0==this.threads.length)throw new ThreadError(this,"threadgroup has no threads");return setTimeout((()=>this.interrupt()),e),this}stop(){if(0==this.threads.length)throw new ThreadError(this,"threadgroup has no threads");for(const e of this.threads)null!=e&&e.stop();return this}stopAfter(e){if(0==this.threads.length)throw new ThreadError(this,"threadgroup has no threads");return setTimeout((()=>this.stop()),e),this}pause(){if(0==this.threads.length)throw new ThreadError(this,"threadgroup has no threads");for(const e of this.threads)null!=e&&(e.paused||e.pause());return this}pauseAfter(e){if(0==this.threads.length)throw new ThreadError(this,"threadgroup has no threads");return setTimeout((()=>this.pause()),e),this}resume(){if(0==this.threads.length)throw new ThreadError(this,"threadgroup has no threads");for(const e of this.threads)null!=e&&e.resume();return this}resumeAfter(e){if(0==this.threads.length)throw new ThreadError(this,"threadgroup has no threads");return setTimeout((()=>this.resume()),e),this}sleep(e){if(0==this.threads.length)throw new ThreadError(this,"threadgroup has no threads");for(const r of this.threads)null!=r&&r.sleep(e);return this}sleepAfter(e){if(0==this.threads.length)throw new ThreadError(this,"threadgroup has no threads");return setTimeout((()=>this.sleep()),e),this}catch(e){return this.__exceptionFunc__=e,this}}class ThreadError extends Error{constructor(e,r){super((e instanceof Thread?"error in thread ":"error in threadgroup ")+'"'+e.id+'", details : '+r,r)}}
