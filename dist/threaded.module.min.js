export class ThreadedTools{}ThreadedTools.acorn={parse(){}},ThreadedTools.walk={fullAncestor(){},simple(){}},ThreadedTools.escodegen={generate(){}};export class Thread{constructor(e,t,r,n){if(void 0===Thread.count&&(Thread.count=0),Thread.count++,this.__func__=e,this.innerfunctionsisolation=void 0!=n&&null!==n&&n,this.__generatorFunc__=ThreadExecutor.__generatorFunc__(e,this.innerfunctionsisolation),this.id=void 0===r?"anonymous thread n-"+Thread.count:r+" (thread n-"+Thread.count+")",void 0===ThreadExecutor.queue&&(ThreadExecutor.queue=[]),this.__sleepingpriority__=!1,this.__resumingpriority__=!1,this.__stepscount__=0,void 0!==t){if("number"!=typeof t)throw new ThreadError("thread priority level must be a valid number",this);if(!Number.isInteger(t))throw new ThreadError("thread priority level must be an integer number",this);if(t<0)throw new ThreadError("thread priority level must be a positive number",this);this.prioritylevel=t}else this.prioritylevel=(t??1)|1;this.__args__=[],this.__result__=null,this.__errorSilently__=!1,this.done=!1,this.started=!1,this.running=!1,this.stopped=!1,this.paused=!1}static innerThreadFor(e,t,r,n,o){void 0===Thread.__sharedinnerthreads__&&(Thread.__sharedinnerthreads__=new Map),Thread.__sharedinnerthreads__.has(e)||Thread.__sharedinnerthreads__.set(e,new Map),Thread.__sharedinnerthreads__.get(e).has(t)||Thread.__sharedinnerthreads__.get(e).set(t,new Thread(t,r,n));let i=Thread.__sharedinnerthreads__.get(e).get(t);return void 0!==r&&i.setPriorityLevel(r),void 0!==n&&i.setId(n),i}setId(e){return this.id=null==e?"anonymous thread n-"+Thread.count:e+" (thread n-"+Thread.count+")",this}setArgs(...e){return this.__args__=e,this}isolateErrors(e){return null==e&&(this.__isolateErrors__=!1),this.__isolateErrors__=e,this}setFunction(e){return this.paused||this.pause(),this.__func__=e,this.__generatorFunc__=ThreadExecutor.__generatorFunc__(this.__func__,this.innerfunctionsisolation),this.started&&this.start(),this}isolateInnerFunctions(e){let t=e;return null==t&&(t=!0),this.innerfunctionsisolation=t,this.paused||this.pause(),this.__generatorFunc__=ThreadExecutor.__generatorFunc__(this.__func__,t),this.started&&this.start(),this}toString(){return this.id}stepsCount(){return this.__stepscount__}setPriorityLevel(e){if("number"!=typeof e)throw new ThreadError("thread priority level must be a valid number",this);if(!Number.isInteger(e))throw new ThreadError("thread priority level must be an integer number",this);if(e<0)throw new ThreadError("thread priority level must be a positive number",this);return this.prioritylevel=e,ThreadExecutor.notifyForPriority(),this}start(){return this.__generator__=void 0,this.__stepscount__=0,this.__sleepingpriority__=!1,this.__resumingpriority__=!1,this.__result__=null,this.done=!1,this.started=!0,this.paused=!1,this.stopped=!1,this.running=!0,ThreadExecutor.__timeSpentOutsideThreads__=void 0,ThreadExecutor.queue.push(this),ThreadExecutor.isHandling()||ThreadExecutor.handleThreadQueue(),this}startAfter(e){return this.paused||this.pause(),setTimeout(()=>this.start(),e),this}interrupt(){return this.stop()}static interrupt(){let e=ThreadExecutor.currentThread;if(null==e)throw new ThreadError("Thread.interrupt called outside thread environment");e.interrupt()}interruptAfter(e){return this.paused||this.pause(),setTimeout(()=>this.interrupt(),e),this}static interruptAfter(e){let t=ThreadExecutor.currentThread;if(null==t)throw new ThreadError("Thread.interruptAfter called outside thread environment");t.interruptAfter(e)}stop(){if(!this.started)return console.error("Thread not started yet"),this;if(this.stopped)return console.error("Thread already stopped"),this;this.stopped=!0,this.running=!1;let e=ThreadExecutor.queue.indexOf(this);if(-1===e)throw new ThreadError('Cannot stop thread "'+sleptThread.id+", the thread is not in the execution queue");return ThreadExecutor.queue.splice(e,1),this}static stop(){let e=ThreadExecutor.currentThread;if(null==e)throw new ThreadError("Thread.stop called outside thread environment");e.stop()}stopAfter(e){return setTimeout(()=>this.stop(),e),this}static stopAfter(e){let t=ThreadExecutor.currentThread;if(null==t)throw new ThreadError("Thread.stopAfter called outside thread environment");t.stopAfter(e)}pause(){if(this.paused){console.error("Thread already paused");return}return this.paused=!0,this}static pause(){let e=ThreadExecutor.currentThread;if(null==e)throw new ThreadError("Thread.pause called outside thread environment");e.pause()}pauseAfter(e){return setTimeout(()=>this.pause(),e),this}static pauseAfter(e){let t=ThreadExecutor.currentThread;if(null==t)throw new ThreadError("Thread.pauseAfter called outside thread environment");t.pauseAfter(e)}resume(){if(!this.paused){console.error("Thread is not paused");return}let e=ThreadExecutor.queue.indexOf(this);if(-1===e)throw new ThreadError('Cannot resume thread "'+sleptThread.id+", the thread is not in the execution queue");return this.paused=!1,this.__resumingpriority__=!0,ThreadExecutor.notifyForResuming(this,e),this}static resume(){let e=ThreadExecutor.currentThread;if(null==e)throw new ThreadError("Thread.resume called outside thread environment");e.resume()}resumeAfter(e){return setTimeout(()=>this.resume(),e),this}static resumeAfter(e){let t=ThreadExecutor.currentThread;if(null==t)throw new ThreadError("Thread.resumeAfter called outside thread environment");t.resumeAfter(e)}sleep(e){if(!this.started)throw new ThreadError('Cannot sleep thread "'+this.id+", the thread is not started yet");if(this.stopped)throw new ThreadError('Cannot sleep thread "'+this.id+", the thread is stopped");if(!this.running)throw new ThreadError('Cannot sleep thread "'+this.id+", the thread is not running");if(this.paused)throw new ThreadError('Cannot sleep thread "'+this.id+", the thread is paused");let t=ThreadExecutor.queue.indexOf(this);if(-1===t)throw new ThreadError('Cannot sleep thread "'+this.id+", the thread is not in the execution queue");return this.sleeping=!0,this.__sleepingpriority__=!0,setTimeout(()=>ThreadExecutor.notifyForSleeping(this,t),e),this}static sleep(e){let t=ThreadExecutor.currentThread;if(null==t)throw new ThreadError("Thread.sleep called outside thread environment");t.sleep(e)}sleepAfter(e,t){return setTimeout(()=>this.sleep(t),e),this}static sleepAfter(e,t){let r=ThreadExecutor.currentThread;if(null==r)throw new ThreadError("Thread.sleepAfter called outside thread environment");r.sleepAfter(e,t)}catch(e){return this.__exceptionFunc__=e,this}result(){return this.__result__}}Thread.LOW_PRIORITY_LEVEL=1,Thread.MID_PRIORITY_LEVEL=2,Thread.HIGH_PRIORITY_LEVEL=3,Thread.innerfunctionsisolation=!1;export class ThreadExecutor{static handleThreadQueue(){void 0!==ThreadExecutor.queue&&0!==ThreadExecutor.queue.length&&(ThreadExecutor.__isLooping__=!0,ThreadExecutor.__isHandling__=!1,ThreadExecutor.__timeSpentOutsideThreads__=void 0,ThreadExecutor.queueIndex=0,ThreadExecutor.currentThread=null,ThreadExecutor.handlerLoop(!1))}static handlerLoop(e){if(void 0!==ThreadExecutor.__timeSpentOutsideThreads__?ThreadExecutor.__timeSpentOutsideThreads__=Date.now()-ThreadExecutor.__timeSpentOutsideThreads__:ThreadExecutor.__timeSpentOutsideThreads__=10,ThreadExecutor.__timeSpentOutsideThreads__=Math.min(ThreadExecutor.__timeSpentOutsideThreads__,20),!e&&ThreadExecutor.__isHandling__)return;let t=ThreadExecutor.queue[ThreadExecutor.queueIndex];if(null!=t){if(t.sleeping||!t.started||t.stopped||!t.running||t.paused)ThreadExecutor.queueIndex++,ThreadExecutor.queueIndex=ThreadExecutor.queueIndex%ThreadExecutor.queue.length;else{ThreadExecutor.__isHandling__=!0,ThreadExecutor.currentThread=t,t.__sleepingpriority__=!1,t.__resumingpriority__=!1,void 0===t.__generator__&&(t.__generator__=t.__generatorFunc__(...t.__args__));let r=t.__generator__.next();t.__stepscount__="number"==typeof r.value?r.value:t.__stepscount__,r instanceof Error||!0!==r.done?(ThreadExecutor.queueIndex++,ThreadExecutor.queueIndex=ThreadExecutor.queueIndex%ThreadExecutor.queue.length):(ThreadExecutor.queue.splice(ThreadExecutor.queueIndex,1),t.__result__=r.value,t.done=!0,t.stopped=!0,t.running=!1,t.__sleepingpriority__=!1,t.__resumingpriority__=!1,ThreadExecutor.queueIndex>=ThreadExecutor.queue.length&&(ThreadExecutor.queueIndex=0)),ThreadExecutor.__isHandling__=!1}}0!==ThreadExecutor.queue.length?(setTimeout(()=>ThreadExecutor.handlerLoop(!1),void 0===ThreadExecutor.__loopingbeattime__||ThreadExecutor.__loopingbeattime__===ThreadExecutor.ADAPTIVE?ThreadExecutor.__timeSpentOutsideThreads__:ThreadExecutor.__loopingbeattime__),ThreadExecutor.__timeSpentOutsideThreads__=Date.now()):ThreadExecutor.__isLooping__=!1}static isHandling(){return void 0!==ThreadExecutor.__isHandling__&&ThreadExecutor.__isHandling__}static isLooping(){return void 0!==ThreadExecutor.__isLooping__&&ThreadExecutor.__isLooping__}static setBeatTime(e){ThreadExecutor.__loopingbeattime__=e}static notifyForSleeping(e,t){for(let r=0;r<ThreadExecutor.queue.length;r++){let n=ThreadExecutor.queue[r];if(!n.__sleepingpriority__){ThreadExecutor.queue.splice(t,1),ThreadExecutor.queue.splice(r,0,e);break}}e.sleeping=!1,ThreadExecutor.__timeSpentOutsideThreads__=void 0,ThreadExecutor.isLooping()?ThreadExecutor.handlerLoop(!0):ThreadExecutor.handleThreadQueue()}static notifyForResuming(e,t){for(let r=0;r<ThreadExecutor.queue.length;r++){let n=ThreadExecutor.queue[r];if(!n.__sleepingpriority__&&!n.__resumingpriority__){ThreadExecutor.queue.splice(t,1),ThreadExecutor.queue.splice(r,0,e);break}}ThreadExecutor.__timeSpentOutsideThreads__=void 0,ThreadExecutor.isLooping()?ThreadExecutor.handlerLoop(!0):ThreadExecutor.handleThreadQueue()}static notifyForPriority(){let e=ThreadExecutor.queue.length;for(let t=0;t<ThreadExecutor.queue.length;t++){let r=ThreadExecutor.queue[t];if(!r.__sleepingpriority__&&!r.__resumingpriority__){e=t;break}}ThreadExecutor.queue.length-e!=0&&(ThreadExecutor.queue=ThreadExecutor.queue.slice(0,e).concat(ThreadExecutor.queue.slice(e,ThreadExecutor.queue.length).sort((e,t)=>((e.prioritylevel??1)|1)-((t.prioritylevel??1)|1))),ThreadExecutor.__timeSpentOutsideThreads__=void 0,ThreadExecutor.isLooping()?ThreadExecutor.handlerLoop(!0):ThreadExecutor.handleThreadQueue())}static catch(e){ThreadExecutor.__globalExceptionFunc__=e}static __threadExceptionOccurred__(e){if(e instanceof TypeError&&"Generator is already running"===e.message)return;e=new ThreadError(e,ThreadExecutor.currentThread);let t=!1;void 0!==ThreadExecutor.__globalExceptionFunc__&&null!==ThreadExecutor.__globalExceptionFunc__?ThreadExecutor.currentThread.__errorSilently__||ThreadExecutor.__globalExceptionFunc__(e,ThreadExecutor.currentThread):t=!0,void 0!==ThreadExecutor.currentThread&&null!==ThreadExecutor.currentThread&&(void 0===ThreadExecutor.currentThread.__threadgroup__||null===ThreadExecutor.currentThread.__threadgroup__||void 0===ThreadExecutor.currentThread.__threadgroup__.__exceptionFunc__||null===ThreadExecutor.currentThread.__threadgroup__.__exceptionFunc__||(t=!1,ThreadExecutor.currentThread.__errorSilently__||ThreadExecutor.currentThread.__threadgroup__.__exceptionFunc__(e,ThreadExecutor.currentThread)),void 0!==ThreadExecutor.currentThread.__exceptionFunc__&&null!==ThreadExecutor.currentThread.__exceptionFunc__&&(t=!1,ThreadExecutor.currentThread.__exceptionFunc__(e)),t&&!ThreadExecutor.currentThread.__errorSilently__&&console.error(e))}static __generatorFunc__(func,innerfunctionsisolation){let functionSource=`(${func.toString()})`;if(null===functionSource)throw new ThreadError("Failed to retrieve the function source code");if(ThreadExecutor.__isNativeFunction__(func))throw new ThreadError("Can't execute native function \""+functionSource+'", the thread function has to be a normal function, try to wrap the function into a normal function instead...');let ast=ThreadedTools.acorn.parse(functionSource,{ecmaVersion:"latest"}),alreadyAGeneratorFunction;"function"==typeof func&&func.constructor&&"GeneratorFunction"===func.constructor.name||ThreadedTools.walk.fullAncestor(ast,(node,ancestors)=>{let functionId=0;if("BlockStatement"===node.type){for(let i=ancestors.length-1;i>=0;i--){let ancestor=ancestors[i];if("FunctionDeclaration"===ancestor.type||"FunctionExpression"===ancestor.type||"ArrowFunctionExpression"===ancestor.type){let functioncode=ThreadedTools.escodegen.generate(ancestor),func=null;try{func=eval(`(${functioncode})`)}catch(ex){}let isFunctionGenerator;if(null!==func&&"function"==typeof func&&func.constructor&&"GeneratorFunction"===func.constructor.name)return;"ArrowFunctionExpression"===ancestor.type&&(ancestor.type="FunctionExpression",ancestor.id=null,ancestor.expression=void 0,"BlockStatement"!==node.body.type&&ThreadExecutor.__wrapArrowFunctionInBlockStatement__(ancestor))}}let newBody=[];for(let i=0;i<node.body.length;i++){let stmt=node.body[i];if((!0===Thread.innerfunctionsisolation||!0==innerfunctionsisolation)&&("VariableDeclaration"===stmt.type||"ExpressionStatement"===stmt.type||"FunctionDeclaration"===stmt.type||"ArrowFunctionDeclaration"===stmt.type)){let originalVarName="VariableDeclaration"===stmt.type?stmt.declarations[0].id.name:null,callExpr="VariableDeclaration"===stmt.type?stmt.declarations[0].init:stmt.expression,functionCallee=null,isNativeOrThreadFunction=!1,dontIsolateToThread=!1;if("ArrowFunctionExpression"===callExpr.type){for(let declarator of stmt.declarations)if("VariableDeclarator"===declarator.type&&"Identifier"===declarator.id.type){let varName=declarator.id.name;functionCallee={type:"Identifier",name:varName}}isNativeOrThreadFunction=ThreadExecutor.__isNativeOrThreadFunction__(eval("("+ThreadedTools.escodegen.generate(callExpr)+")")),dontIsolateToThread=!0}else{if(void 0!==(functionCallee=callExpr.callee)&&null!==functionCallee)try{isNativeOrThreadFunction=ThreadExecutor.__isNativeOrThreadFunction__(eval(ThreadedTools.escodegen.generate(functionCallee)))}catch(ex){isNativeOrThreadFunction=!1}dontIsolateToThread="CallExpression"!==callExpr.type}if(isNativeOrThreadFunction||dontIsolateToThread){newBody.push(stmt),newBody.push({type:"ExpressionStatement",expression:{type:"YieldExpression",argument:{type:"UpdateExpression",operator:"++",argument:{type:"Identifier",name:"__thefunctionstepscount__"},prefix:!1}}});continue}if(!dontIsolateToThread){let threadVar=`__innerfunctionexecutor${++functionId}__`,tempVarName=`__innerfunctionexecutionresult${functionId}__`;newBody.push({type:"VariableDeclaration",kind:"const",declarations:[{type:"VariableDeclarator",id:{type:"Identifier",name:threadVar},init:{type:"CallExpression",callee:{type:"MemberExpression",object:{type:"CallExpression",callee:{type:"MemberExpression",object:{type:"CallExpression",callee:{type:"MemberExpression",object:{type:"CallExpression",callee:{type:"MemberExpression",object:{type:"CallExpression",callee:{type:"MemberExpression",object:{type:"Identifier",name:"Thread"},property:{type:"Identifier",name:"innerThreadFor"},computed:!1,optional:!1},arguments:[{type:"MemberExpression",object:{type:"Identifier",name:"ThreadExecutor"},property:{type:"Identifier",name:"currentThread"},computed:!1,optional:!1},functionCallee]},property:{type:"Identifier",name:"setId"},computed:!1,optional:!1},arguments:[{type:"BinaryExpression",operator:"+",left:{type:"MemberExpression",object:{type:"MemberExpression",object:{type:"Identifier",name:"ThreadExecutor"},property:{type:"Identifier",name:"currentThread"},computed:!1,optional:!1},property:{type:"Identifier",name:"id"},computed:!1,optional:!1},right:{type:"Literal",value:"'s inner thread",raw:"'s inner thread"}}]},property:{type:"Identifier",name:"setArgs"},computed:!1,optional:!1},arguments:callExpr.arguments},property:{type:"Identifier",name:"isolateErrors"},computed:!1,optional:!1},arguments:[{type:"Literal",value:!0,raw:"true"}]},property:{type:"Identifier",name:"start"},computed:!1,optional:!1},arguments:[]}}]},{type:"WhileStatement",test:{type:"MemberExpression",object:{type:"Identifier",name:threadVar},property:{type:"Identifier",name:"running"}},body:{type:"BlockStatement",body:[{type:"ExpressionStatement",expression:{type:"YieldExpression",argument:{type:"Identifier",name:"__thefunctionstepscount__"}}}]}},{type:"VariableDeclaration",kind:"let",declarations:[{type:"VariableDeclarator",id:{type:"Identifier",name:null!==originalVarName?originalVarName:tempVarName},init:{type:"CallExpression",callee:{type:"MemberExpression",object:{type:"Identifier",name:threadVar},property:{type:"Identifier",name:"result"}},arguments:[]}}]},{type:"ExpressionStatement",expression:{type:"YieldExpression",argument:{type:"UpdateExpression",operator:"++",argument:{type:"Identifier",name:"__thefunctionstepscount__"},prefix:!1}}},{type:"IfStatement",test:{type:"BinaryExpression",operator:"instanceof",left:{type:"Identifier",name:null!==originalVarName?originalVarName:tempVarName},right:{type:"Identifier",name:"Error"}},consequent:{type:"BlockStatement",body:[{type:"ThrowStatement",argument:{type:"NewExpression",callee:{type:"Identifier",name:"ThreadError"},arguments:[{type:"Identifier",name:null!==originalVarName?originalVarName:tempVarName},{type:"VariableDeclarator",id:{type:"Identifier",name:threadVar}}]}}]},alternate:null})}}else newBody.push(stmt),"ReturnStatement"!==stmt.type&&"ContinueStatement"!==stmt.type&&"BreakStatement"!==stmt.type&&"ThrowStatement"!==stmt.type&&newBody.push({type:"ExpressionStatement",expression:{type:"YieldExpression",argument:{type:"UpdateExpression",operator:"++",argument:{type:"Identifier",name:"__thefunctionstepscount__"},prefix:!1}}})}return node.body=newBody,node}}),ThreadedTools.walk.simple(ast,{FunctionDeclaration(e){ThreadExecutor.__wrapFunctionBodyInTryCatch__(e,!e.generator,!0),e.generator=!0},FunctionExpression(e){ThreadExecutor.__wrapFunctionBodyInTryCatch__(e,!e.generator,!0),e.generator=!0},ArrowFunctionExpression(e){"BlockStatement"!==e.body.type&&ThreadExecutor.__wrapArrowFunctionInBlockStatement__(e),ThreadExecutor.__wrapFunctionBodyInTryCatch__(e,!e.generator,!0),e.type="FunctionExpression",e.generator=!0,e.expression=!1}});let newCode,generatorFunc;return eval(ThreadedTools.escodegen.generate(ast))}static __isNativeFunction__(e){if(void 0===e)return!1;let t="function"==typeof e&&e.toString().includes("[native code]")||e.toString().includes("[wasm code]");return t||(t="function"==typeof e&&/#\w+/.test(e.toString())),t}static __isNativeOrThreadFunction__(e){return void 0!==e&&(ThreadExecutor.__isNativeFunction__(e)||Thread.prototype.hasOwnProperty(e.name))}static __wrapArrowFunctionInBlockStatement__(e){e.body,e.expression&&(e.body={type:"BlockStatement",body:[{type:"ReturnStatement",argument:e.body}]},e.expression=!1)}static __wrapFunctionBodyInTryCatch__(e,t,r){let n=e.body.body;e.body.body=[{type:"TryStatement",block:{type:"BlockStatement",body:[!0===r?{type:"IfStatement",test:{type:"BinaryExpression",operator:"==",left:{type:"MemberExpression",object:{type:"Identifier",name:"ThreadExecutor"},property:{type:"Identifier",name:"currentThread"},computed:!1},right:{type:"Literal",value:null,raw:"null"}},consequent:{type:"BlockStatement",body:[{type:"ThrowStatement",argument:{type:"NewExpression",callee:{type:"Identifier",name:"ThreadError"},arguments:[{type:"Literal",value:"a thread function called outside thread environment",raw:'"a thread function called outside thread environment"'}]}}]}}:{type:"EmptyStatement"},!0===t?{type:"VariableDeclaration",declarations:[{type:"VariableDeclarator",id:{type:"Identifier",name:"__thefunctionstepscount__"},init:{type:"Literal",value:0}}],kind:"let"}:{type:"EmptyStatement"},...n]},handler:{type:"CatchClause",param:{type:"Identifier",name:"ex"},body:{type:"BlockStatement",body:[{type:"ExpressionStatement",expression:{type:"CallExpression",callee:{type:"MemberExpression",object:{type:"Identifier",name:"ThreadExecutor"},property:{type:"Identifier",name:"__threadExceptionOccurred__"}},arguments:[{type:"Identifier",name:"ex"}]}},{type:"ReturnStatement",argument:{type:"Identifier",name:"ex"}}]}},finalizer:null}]}}ThreadExecutor.ADAPTIVE=-1;export class ThreadGroup{constructor(...e){for(let t of(void 0===ThreadGroup.count&&(ThreadGroup.count=0),ThreadGroup.count++,this.id="anonymous threadgroup n-"+ThreadGroup.count,null==e?this.threads=[]:this.threads=e,this.threads))null!=t&&(t.__threadgroup__=this)}setId(e){return this.id=null==e?"anonymous threadgroup n-"+ThreadGroup.count:e+" (threadgroup n-"+ThreadGroup.count+")",this}add(e){if(null==e)throw new ThreadError("Given thread in threadgroup add function is undefined or null",this);return this.threads.push(e),e.__threadgroup__=this,this}remove(e){if(null==e)return;let t=this.threads.indexOf(e);if(-1===t)throw new ThreadError('Cannot remove thread "'+e.id+" from threadgroup, the thread is not added to that threadgroup");return this.threads.splice(t,1),e.__threadgroup__=void 0,this}stepsCount(){if(0==this.threads.length)throw new ThreadError("threadgroup has no threads",this);let e=0;for(let t of this.threads)null!=t&&(e+=t.stepsCount());return e}start(){if(0==this.threads.length)throw new ThreadError("threadgroup has no threads",this);for(let e of this.threads)null!=e&&e.start();return this}startAfter(e){if(0==this.threads.length)throw new ThreadError("threadgroup has no threads",this);return this.pause(),setTimeout(()=>this.start(),e),this}interrupt(){if(0==this.threads.length)throw new ThreadError("threadgroup has no threads",this);return this.stop()}interruptAfter(e){if(0==this.threads.length)throw new ThreadError("threadgroup has no threads",this);return setTimeout(()=>this.interrupt(),e),this}stop(){if(0==this.threads.length)throw new ThreadError("threadgroup has no threads",this);for(let e of this.threads)null!=e&&e.stop();return this}stopAfter(e){if(0==this.threads.length)throw new ThreadError("threadgroup has no threads",this);return setTimeout(()=>this.stop(),e),this}pause(){if(0==this.threads.length)throw new ThreadError("threadgroup has no threads",this);for(let e of this.threads)null==e||e.paused||e.pause();return this}pauseAfter(e){if(0==this.threads.length)throw new ThreadError("threadgroup has no threads",this);return setTimeout(()=>this.pause(),e),this}resume(){if(0==this.threads.length)throw new ThreadError("threadgroup has no threads",this);for(let e of this.threads)null!=e&&e.resume();return this}resumeAfter(e){if(0==this.threads.length)throw new ThreadError("threadgroup has no threads",this);return setTimeout(()=>this.resume(),e),this}sleep(e){if(0==this.threads.length)throw new ThreadError("threadgroup has no threads",this);for(let t of this.threads)null!=t&&t.sleep(e);return this}sleepAfter(e){if(0==this.threads.length)throw new ThreadError("threadgroup has no threads",this);return setTimeout(()=>this.sleep(),e),this}catch(e){return this.__exceptionFunc__=e,this}}export class ThreadError extends Error{constructor(e,t){super((void 0===t?"error in a thread function":(t instanceof Thread?"error in thread ":"error in threadgroup ")+'"'+t.id+'"')+", details : "+e,e instanceof Error?e:void 0)}}try{module.exports={Thread,ThreadGroup,ThreadExecutor,ThreadError,ThreadedTools}}catch(ex){}